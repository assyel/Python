# 4.1. Напишите функцию square, принимающую 1 аргумент — сторону квадрата, 
# и возвращающую 3 значения (с помощью кортежа): 
# периметр квадрата, площадь квадрата и диагональ квадрата.
def square(side):
    perimeter = 4 * side
    area = side ** 2
    diagonal = side * (2 ** 0.5) # вычисляем диагональ как сторона умноженная на корень из двух
    return (perimeter, area, diagonal)

# Вы можете вызвать эту функцию, 
# передав ей сторону квадрата в качестве аргумента, например:
result = square(5)
print(result) # (20, 25, 7.0710678118654755)


# Вывод будет `(20, 25, 7.0710678118654755)`, 
# что обозначает периметр 20, площадь 25 и диагональ 7.0710678118654755 для квадрата со стороной 5.

# 4.2. Напишите фукнцию, которая принимает произвольное количество именнованных аргументов и выводит их построчно 
#      в формате аргумент: значение. Например:
# 	name: John
# 	last_name: Smith
# 	age: 35 
# 	position: web developer
def print_kwargs(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")
# Конструкция произвольного количества именнованных аргументов 
# осуществляется с помощью двух символов звездочки (*) и двойных 
# звездочек (**). Символ * позволяет передавать будет кортеж 
# неименованных аргументов в виде (args), а ** передаст словарь 
# именнованных аргументов в виде (kwargs). 

# Эта функция будет печатать все именнованные аргументы и их значения 
# построчно, используя форматирование строк f-strings. Можно передать 
# любое количество именнованных аргументов.Символ ":" служит для 
# разделения имени аргумента и значения, чтобы легче было читать.

#Вы можете вызвать эту функцию и передать любые именнованные аргументы, например:
print_kwargs(name='John', last_name='Smith', age=35, position='web developer')

# 4.3. Используя лямбда-выражение, из списка my_list = [20, -3, 15, 2, -1, -21] 
# создайте новый список, содержащий только положительные числа
my_list = [20, -3, 15, 2, -1, -21]
positive_numbers = list(filter(lambda x: x > 0, my_list))
print(positive_numbers)

#Option 2
my_list = [20, -3, 15, 2, -1, -21]
positive_numbers = list(filter(lambda x: x if x > 0 else None, my_list))
print(positive_numbers)

# Option 3
my_list = [20, -3, 15, 2, -1, -21]
positive_numbers = list(filter(lambda x: True if x > 0 else False, my_list))
print(positive_numbers)

# 4.4. Используя лямбда выражение, 
# получите результат перемножения значений в предыдущем списке 
from functools import reduce

my_list = [20, -3, 15, 2, -1, -21]
product = reduce(lambda x, y: x * y, my_list)
print(product)

# Лямбда-выражение lambda x, y: x * y принимает два аргумента x и y и 
# возвращает их произведение. Далее мы используем функцию reduce из 
# модуля functools, чтобы свести все элементы списка my_list к 
# единственному значению путем их последовательных разделений.

# # 4.5. Напишите декоратор, который высчитывает время работы функции, 
# которую он принимает в качестве параметра 
#Декоратор - это функция, которая принимает другую функцию в качестве 
# аргумента и изменяет ее поведение, не изменяя саму функцию. 
# Декораторы используются, когда требуется добавить определенное 
#поведение функции, но не изменять ее непосредственно. 
#Декоратор для вычисления времени выполнения функции можно написать 
# следующим образом:
import time

def calculate_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print("Функция {} выполнялась {:.6f} секунд".format(func.__name__, end_time - start_time))
        return result
    return wrapper


# В этом декораторе мы определяем функцию-обертку `wrapper`, которая 
# получает на вход функцию `func`, для которой мы хотим измерить время
# выполнения. Внутри функции-обертки `wrapper` мы берем текущее время 
# перед выполнением функции `func`, затем выполняем функцию и снова 
# берем время. После этого вычисляем разницу между двумя временными 
# метками и выводим результат на экран.
#Использование декоратора приведено ниже:

@calculate_time
def my_function(t, b):
    time.sleep(1)
    return t * b
    # ваш код 
    
my_function()


# В данном случае при вызове функции `my_function` будут выведены на 
# экран данные о времени ее выполнения. 

# 4.6. Создайте файл my_calc.py и пропишите в нем минимум 4 функции, 
# выполняющие базовые арифметические вычисления. Примените эти 
# функции в качестве методов в другом файле. 

#для начала создадим файл my_calc.py с базовыми арифметическими 
# функциями. 

def add(num1, num2):
    """Функция сложения"""
    return num1 + num2

def sub(num1, num2):
    """Функция вычитания"""
    return num1 - num2

def mul(num1, num2):
    """Функция умножения"""
    return num1 * num2

def div(num1, num2):
    """Функция деления"""
    if num2 == 0:
        raise ValueError("На ноль делить нельзя!")
    return num1 / num2

#теперь мы можем использовать эти функции в другом файле. 
# Для этого создадим новый файл my_program.py и подключим наш 
# модуль my_calc.py:


from my_calc import add, sub, mul, div

# Пример использования функций:
result = add(2, 3)
print(result)

result = sub(10, 5)
print(result)

result = mul(4, 6)
print(result)

result = div(10, 2)
print(result)
```

#В этом примере мы использовали функции add, sub, mul и div из модуля 
# my_calc для выполнения базовых арифметических операций. Код работает
# корректно и выводит результаты вычислений.


	