# Functions. Global, local and nonlocal variables. Variable scopes
# 1
def s():
    #local
    a, b, c = 1, 2, 4
    # 4 к переменной попробуем присвоить новое значение
    w = 'ASSEL'
    # 6 через идентификатор id можем определить идентификатор нашей 
    # переменной. и увидим что разные id у двух перенных w
    print(id(w))
    print(a, b, c, w)
# 3 global. если мы добавим w выше к переменным и вызовем s(), то 
# получим результат bope
w = 'assel'
print(id(w))
y = 100
s()
# 5 проверим в глобальной переменной изменилось ли значение assel на bope. 
# и видим что assel осталось
print(w)
# здесь если вне функции вызовем, то получим ошибку
#print(a)

# 2 значения в этой функции не относится к предыдущей функции. 
# мы здесь не можем обращаться к переменной a
def q():
    r, t = 1, 5
    print(r, t)
q()
# 7 при выведении разные переменные выводятся как положено.

def s():
    #а если удалим или замютим одну из переменных внутри функции, то он будет 
    # находить в глобальной переменной: замютили с = 33, вместо этого вывелась 
    # глобальная переменная с = 300. А если убрать все локальные переменные, то 
    # выводятся 2 раза глобальные переменные
    #a = 11
    #b = 22
    #c = 33
    print(a, b, c, 'local')
# global 
a = 100
b = 200
c = 300
s()
print(a, b, c, 'global')
# 8 global переменные могут стать local, если передадим внутри функции 
# параметры
def s(a, b,c):
    # если будем изменять, то эти изменения распространятся только внутри функции.
    # то есть на саму функцию a вне функции это не влияет. 
    a = 30
    print(a, b, c, 'local')
# global
a = 100
b = 200
c = 300
s(a, b, c)
print(a, b, c, 'global')
# 9 Давайте в глобальную переменную a поместим список и убедимся, что изменения 
# внутри функции не коснется значения этого созданного списка. так как элементы
# в ОБОИХ переменных изменяются, надо быть осторожным в данном случае - элемент 2 
# изменился на 100
def s(a, b,c):
    #a = 30
    # 10 так как список является изменяемым обьектом, то мы внутри функции 
    # можем обратиться к какому либо конкретному значению и изменить его на новое.
    a[1] = 100
    print(a, b, c, 'local')
# global
a = [1,2,4,5,6]
b = 200
c = 300
s(a, b, c)
print(a, b, c, 'global')
# 11 Если внутри функции вам необходимо изменить значение глобальной переменной,
# это делается при помощи инструкции global. После этого все изменения внутри 
# функции будут влиять на глобальные переменные:
def s():
    global a
    a = 30 

# global
a = [1,2,4,5,6]
s()
print(a, 'global')
# 12 Built-in scope
def w(x):
    return x**2
# на имя abs присваиваю имя функцию w и тогда под именем abs будет скрываться 
# нахождение квадрата числа.
abs = w 
print(abs(-7))
# 12
def s():
    #local
    abs = 200
    def q():
        abs = 'hello'
        print(abs, 'q')
    # функцию q вызывать можем только внутри функции s:
    # enclosing scope = обьемлющая видимость
    q()
    print(abs, 's')
#global
abs = [1,2,3]
s()
# 13 Если нам понадобится инструкцию abs = 200 в функции s изменить 
# внутри функции q, то берем инструкцию nonlocal. Выводится hello 2 раза
# с функций q и s.

def s():
    #local
    abs = 200
    def q():
        nonlocal abs 
        abs = 'hello'
        print(abs, 'q')
    # функцию q вызывать можем только внутри функции s:
    # enclosing scope = обьемлющая видимость
    q()
    print(abs, 's')
#global
abs = [1,2,3]
s()




