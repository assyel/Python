#Передача аргументов
# 1
def f(a,b):
    # 2 id сравниваем
    print(id(a), id(b), 'local')
    a = 100
    b = 200
    #print(a,b, 'local')
    print(id(a), id(b), 'local after')
c = 'hello'
d = [1,2,4,6,76]
print(id(c), id(d), 'global')
#3 передача происходит там, где f(c,d). В момент передачи автоматическое
#  присвоение: a=с и b=d (мындағы a и b ол f(a, b), төменгісі емес). 
#4 Мына результаттарда алғашқы екі id бірдей, өйткені присвеониесі 
# бірдей 4424893264 4424894224 global
#4424893264 4424894224 local
#4424895824 4424899024 local after 
# изменение локальных переменных никак не затрагивает глобальных 
# переменных
f(c,d)
print(c,d, 'global')
#5   
def f(a,b):
    print(id(a), id(b), 'local')
    a = 100
    # 6 В нашем примере локальная переменная b ссылается на список,
    # значит мы легко можем добавить какие л значения или изменить 
    # имеющийся обьект. хотя обращаемся через переменную b, в глобальной 
    # переменной происходит изменение, потому что список это изменяемый
    # обект. это произошло потому что локальная и глобальная переменные 
    # ссылались на один и тот же список.
    b.append(100)
    b[1] = 'hi'
    #print(a,b, 'local')
    print(id(a), id(b), 'local after')

c = 'hello'
d = [1,2,4,6,76]
print(id(c), id(d), 'global')
f(c,d)
print(c,d, 'global')
#7 ЧТОБЫ ИЗБЕЖАТЬ ИЗМЕНЕНИЯ ВНУТРИ ФУНКЦИИ ВЫ МОЖЕТЕ ВО ВРЕМЯ ПЕРЕДАЧИ
    # передавать копию списка d. Это можно делать с помощью среза [:] и тогда
    # наш список не изменится и мы получим то что хотели. 
def f(a,b):
    print(id(a), id(b), 'local')
    a = 100
    b.append(100)
    b[1] = 'hi'
    #print(a,b, 'local')
    print(id(a), id(b), 'local after')

c = 'hello'
d = [1,2,4,6,76]
print(id(c), id(d), 'global')
f(c,d[:])
print(c,d, 'global')
#8 Какие есть варианты вызова? 
def f(a,b,c):
    print(a,b,c)
#позиционный в том же порядке
f(1,5,7)
#по имени. при таком варианте вы не сможете вызвать какие то свои 
# выдуманные имена. 
f(a=10,b=20,c=5)
# комбинированный. если написать так, то получим ошибку (b=20,c=5, 2)
f(2,b=20,c=5)
#по умолчанию. при обявлении функции к некоторым параметрам можно 
# присвоить значения по умолчанию. Если какой то аргумент отсутствует 
# то я не смогу вызвать функцию без передачи аргументов. И во всех 
# аргументах сперва идут обязательные аргументы, затем только по умолчанию.
#
def f(a='tatti',b='bope',c='неизвестно'):
    print(a,b,c)
# здесь всего 2 параметра вызываем, а последнее значение по умолчанию 
#будет вызываться
f(2,3)
#но если дадите 3 параметра, то выводится цифра 4 в данном примере
f(2,3,4)
#внизу если только один параметр вызвать, при функции def f(a,b='bope',
# c='неизвестно'), то увидим 2 послледних параметра по умолчанию
f(2)
# c тремя параметров по умолчанию мы можем вызвать без параметра. все 
# выводится позиционно
f()
#но также можно передавать именованные аргументы
f(b=111)
# Даже если вызовем 3 функции будет ошибка, поскольку обязательные 
# параметры должны стоять ВПЕРЕДИ. ТУТ ошибка. И ЧТОБЫ ВЫЗЫВАТЬ 
# ОБЯЗАТЕЛЬНЫЕ АРГУМЕНТЫ ИМ НАДО ПРИСВОИТЬ ЗНАЧЕНИЯ.
def f(a='tatti',b ,c='неизвестно'):
    print(a,b,c)
f(1,2,3)