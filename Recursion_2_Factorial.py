# Recursion_нахождение факториала
#1 Разберем самую классическую задачу на рекурсии - это 
# нахождение факториала.
    # как находить факториал на примере 5! - это последовательное 
    # произведение всех чисел от 1 до 5. Но если приглядеться, то 
    # 5! включает в себя нахождение 4!, умноженное на 
    # число 5: 4! * 5, то есть 5! = 1*2*3*4*5=4!5 (4*5). В свою очередь 
    # 4! - это последовательное произведение всех чисел от 1 
    # до 4, в которого входит факториал 3!*4=1*2*3*4 (3*4). Дальше 
    # 2!*3=1*2*3 (2*3) и так когда дойдет до 1, то он выйдет из 
    # рекурсии. А когда факториал не равен 1, то мы его ищем последующей 
    # формуле: n! = (n-1)!n. И вот в левой крайне и правой крайней мы 
    # видим факториал. 
    # В этом примере мы можем разобрать вторую составляющую 
    # рекурсию. Если у вас есть какая то большая задача, как, например, найти 
    # n факториал, вы можете рекурсивно свести ее к поиску более 
    # меньшей подзадачи, в которых будет сводится еще более мелкие и тд. 
    # и стремится к выходу. В нашем случае чтобы найти 5! мы 
    # должны найти 4! и умножить его на 5, 4! будет просить нас найти 
    # 3!, который будет просить 2!, дальше 1! и мы выйдем из рекурсии. 
    # а потом обратно также будем возвращаться.
def fact(x):
    # и значит внутри функции мы сперва проверяем на выход, если x == 1, то 
    # мы возвращаем значение 1!, а в противном случае мы вызываем нашу 
    # функцию fact() и передаем ей аргумент на единичку меньше и это 
    # значение по формуле мы должны умножить на x
    if x ==1:
        return 1 
    return fact(x-1)*x
# и вызовем эту функцию и получаем результат 24.
print(fact(4))
# обьясняем. мы вызываем f(4) = f(4-1=3)*4. в свою очередь f(3) будет 
# равна f(2)*3, f(2) тоже вызывает f(1)*2, а f(1) возвращает 
# единицу 1. и соответственно мы возвращаемся здесь назад: 1*2=2, 
# полученное 2*3=6 вышестоящее, и 6*4=24
#2 классическая задача 2 Fibonacci


